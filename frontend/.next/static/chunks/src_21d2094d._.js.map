{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/aviasnani/Desktop/computer%20demo/cs-demo/repo/frontend/src/services/cryptoService.js"],"sourcesContent":["/**\n * CryptoService - Web Crypto API and JSEncrypt wrapper for RSA and AES operations\n * Implements end-to-end encryption functionality for the chat application\n * Uses RSA-2048 for key exchange and AES-256-GCM for message encryption\n */\n\nimport CryptoJS from 'crypto-js';\nimport JSEncrypt from 'jsencrypt';\n\nclass CryptoService {\n    //Generate RSA key pair for initial key exchange\n  \n    static async generateRSAKeyPair() {\n        try {\n            console.log('Generating RSA-2048 key pair...');\n            \n            // Check if Web Crypto API is available\n            if (!crypto || !crypto.subtle || !crypto.subtle.generateKey) {\n                console.warn('Web Crypto API not available, using JSEncrypt fallback');\n                return this._generateRSAKeyPairFallback();\n            }\n            \n            // Generate RSA key pair with EXACT same parameters\n            const keyPair = await crypto.subtle.generateKey(\n                {\n                    name: 'RSA-OAEP',\n                    modulusLength: 2048,\n                    publicExponent: new Uint8Array([1, 0, 1]),\n                    hash: 'SHA-256'\n                },\n                true,\n                ['encrypt', 'decrypt']\n            );\n            \n            const publicKeyBuffer = await crypto.subtle.exportKey('spki', keyPair.publicKey);\n            const privateKeyBuffer = await crypto.subtle.exportKey('pkcs8', keyPair.privateKey);\n            \n            const publicKeyPem = this._arrayBufferToPem(publicKeyBuffer, 'PUBLIC KEY');\n            const privateKeyPem = this._arrayBufferToPem(privateKeyBuffer, 'PRIVATE KEY');\n            \n            console.log('RSA key pair generated successfully');\n            console.log('Public key length:', publicKeyPem.length);\n            console.log('Private key length:', privateKeyPem.length);\n            \n            return {\n                publicKey: publicKeyPem,\n                privateKey: privateKeyPem\n            };\n        } catch (error) {\n            console.error('RSA key generation failed:', error);\n            throw new Error(`Failed to generate RSA key pair: ${error.message}`);\n        }\n    }\n\n    /**\n     * Export RSA public key\n     */\n    static async exportPublicKey(publicKey) {\n        try {\n            return publicKey; // Just return the PEM string directly - simpler!\n        } catch (error) {\n            throw new Error(`Failed to export public key: ${error.message}`);\n        }\n    }\n\n    /**\n     * Import RSA public key\n     */\n    static async importPublicKey(publicKeyPem) {\n        try {\n            return publicKeyPem; // Just return the PEM string directly - simpler!\n        } catch (error) {\n            throw new Error(`Failed to import public key: ${error.message}`);\n        }\n    }\n\n    /**\n     * Encrypt data using RSA public key with Web Crypto API\n     */\n    static async encryptWithRSA(data, publicKeyPem) {\n        console.log('RSA Encryption Starting...');\n        console.log('Data to encrypt:', JSON.stringify(data));\n        console.log('Data length:', data?.length);\n        console.log('Public key preview:', publicKeyPem?.substring(0, 150));\n        console.log('Public key length:', publicKeyPem?.length);\n        \n        try {\n            // Step 1: Validate input\n            if (!data || !publicKeyPem) {\n                throw new Error('Missing data or public key');\n            }\n            \n            // Step 2: Import the public key\n            console.log('Step 2: Importing public key...');\n            let publicKey;\n            try {\n                publicKey = await this._importPublicKey(publicKeyPem);\n                console.log('Public key imported successfully');\n            } catch (importError) {\n                console.error('Public key import failed:', importError);\n                throw new Error(`Public key import failed: ${importError.message}`);\n            }\n            \n            // Step 3: Prepare data\n            console.log('Step 3: Preparing data buffer...');\n            const dataBuffer = new TextEncoder().encode(data);\n            console.log('Data buffer created, length:', dataBuffer.length);\n            \n            // Check data size limit (RSA-2048 can encrypt ~190 bytes with OAEP)\n            if (dataBuffer.length > 190) {\n                throw new Error(`Data too large: ${dataBuffer.length} bytes (max ~190 for RSA-2048 OAEP)`);\n            }\n            \n            // Step 4: Encrypt\n            console.log('Step 4: Encrypting with RSA-OAEP...');\n            let encryptedBuffer;\n            try {\n                encryptedBuffer = await crypto.subtle.encrypt(\n                    {\n                        name: 'RSA-OAEP'\n                    },\n                    publicKey,\n                    dataBuffer\n                );\n                console.log('Encryption completed, buffer length:', encryptedBuffer.byteLength);\n            } catch (encryptError) {\n                console.error('Encryption operation failed:', encryptError);\n                throw new Error(`Encryption operation failed: ${encryptError.message}`);\n            }\n            \n            // Step 5: Convert to base64\n            console.log('Step 5: Converting to base64...');\n            const encryptedArray = new Uint8Array(encryptedBuffer);\n            const encrypted = btoa(String.fromCharCode(...encryptedArray));\n            \n            console.log('RSA encryption successful! Result length:', encrypted.length);\n            return encrypted;\n            \n        } catch (error) {\n            console.error('RSA Encryption FAILED:', {\n                errorName: error.name,\n                errorMessage: error.message,\n                errorStack: error.stack,\n                inputData: data,\n                keyPreview: publicKeyPem?.substring(0, 100)\n            });\n            \n            throw new Error(`Failed to encrypt with RSA: ${error.message || 'Unknown encryption error'}`);\n        }\n    }\n\n    /**\n     * Decrypt data using RSA private key with Web Crypto API\n     */\n    static async decryptWithRSA(encryptedData, privateKeyPem) {\n        try {\n            console.log('RSA Decryption starting...');\n            console.log('Encrypted data length:', encryptedData?.length);\n            console.log('Private key length:', privateKeyPem?.length);\n            \n            // Import the private key\n            const privateKey = await this._importPrivateKey(privateKeyPem);\n            console.log('Private key imported successfully');\n            \n            // Convert base64 to ArrayBuffer\n            let encryptedArray;\n            try {\n                const binaryString = atob(encryptedData);\n                encryptedArray = new Uint8Array(binaryString.length);\n                for (let i = 0; i < binaryString.length; i++) {\n                    encryptedArray[i] = binaryString.charCodeAt(i);\n                }\n                console.log('Encrypted data converted to array, length:', encryptedArray.length);\n            } catch (b64Error) {\n                console.error('Base64 decode failed:', b64Error);\n                throw new Error(`Invalid base64 data: ${b64Error.message}`);\n            }\n            \n            // Decrypt with RSA-OAEP\n            console.log('Attempting RSA-OAEP decryption...');\n            const decryptedBuffer = await crypto.subtle.decrypt(\n                {\n                    name: 'RSA-OAEP'\n                },\n                privateKey,\n                encryptedArray\n            );\n            \n            // Convert back to string\n            const decrypted = new TextDecoder().decode(decryptedBuffer);\n            console.log('RSA decryption successful, result length:', decrypted.length);\n            \n            return decrypted;\n        } catch (error) {\n            console.error('RSA Decryption error:', error.name, error.message);\n            throw new Error(`Failed to decrypt with RSA: ${error.message}`);\n        }\n    }\n\n    /**\n     * Sign data using RSA private key with Web Crypto API\n     */\n    static async signWithRSA(data, privateKeyPem) {\n        try {\n            console.log('RSA Signing with Web Crypto API');\n            \n            // Import the private key for signing\n            const buffer = this._pemToArrayBuffer(privateKeyPem);\n            const privateKey = await crypto.subtle.importKey(\n                'pkcs8',\n                buffer,\n                {\n                    name: 'RSA-PSS',\n                    hash: 'SHA-256'\n                },\n                false,\n                ['sign']\n            );\n            \n            // Sign the data\n            const dataBuffer = new TextEncoder().encode(data);\n            const signatureBuffer = await crypto.subtle.sign(\n                {\n                    name: 'RSA-PSS',\n                    saltLength: 32\n                },\n                privateKey,\n                dataBuffer\n            );\n            \n            // Convert to base64\n            const signatureArray = new Uint8Array(signatureBuffer);\n            const signature = btoa(String.fromCharCode(...signatureArray));\n            \n            console.log('RSA signing successful');\n            return signature;\n        } catch (error) {\n            console.error('RSA Signing error:', error);\n            throw new Error(`Failed to sign with RSA: ${error.message}`);\n        }\n    }\n\n    /**\n     * Verify RSA signature using public key with Web Crypto API\n     */\n    static async verifyRSASignature(data, signature, publicKeyPem) {\n        try {\n            console.log('RSA Signature verification with Web Crypto API');\n            \n            // Import the public key for verification\n            const buffer = this._pemToArrayBuffer(publicKeyPem);\n            const publicKey = await crypto.subtle.importKey(\n                'spki',\n                buffer,\n                {\n                    name: 'RSA-PSS',\n                    hash: 'SHA-256'\n                },\n                false,\n                ['verify']\n            );\n            \n            // Convert signature from base64\n            const signatureArray = new Uint8Array(\n                atob(signature).split('').map(char => char.charCodeAt(0))\n            );\n            \n            // Verify the signature\n            const dataBuffer = new TextEncoder().encode(data);\n            const isValid = await crypto.subtle.verify(\n                {\n                    name: 'RSA-PSS',\n                    saltLength: 32\n                },\n                publicKey,\n                signatureArray,\n                dataBuffer\n            );\n            \n            console.log('RSA signature verification result:', isValid);\n            return isValid;\n        } catch (error) {\n            console.error('RSA Signature verification error:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Generate AES key for message encryption using Web Crypto API\n     */\n    static async generateAESKey() {\n        try {\n            // Generate 256-bit AES key using Web Crypto API\n            const key = await crypto.subtle.generateKey(\n                {\n                    name: 'AES-GCM',\n                    length: 256\n                },\n                true, // extractable\n                ['encrypt', 'decrypt']\n            );\n\n            // Export key as raw bytes and convert to hex\n            const keyBuffer = await crypto.subtle.exportKey('raw', key);\n            const keyArray = new Uint8Array(keyBuffer);\n            return Array.from(keyArray).map(b => b.toString(16).padStart(2, '0')).join('');\n        } catch (error) {\n            throw new Error(`Failed to generate AES key: ${error.message}`);\n        }\n    }\n\n    /**\n     * Encrypt message using AES-256-GCM with Web Crypto API\n     */\n    static async encryptWithAES(message, aesKeyHex) {\n        try {\n            // Generate random IV for each message (96-bit IV for GCM)\n            const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV for GCM\n\n            // Convert hex key to Uint8Array\n            const keyBytes = new Uint8Array(aesKeyHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));\n\n            // Import the key\n            const key = await crypto.subtle.importKey(\n                'raw',\n                keyBytes,\n                { name: 'AES-GCM' },\n                false,\n                ['encrypt']\n            );\n\n            // Encrypt the message\n            const messageBytes = new TextEncoder().encode(message);\n            const encryptedBuffer = await crypto.subtle.encrypt(\n                {\n                    name: 'AES-GCM',\n                    iv: iv\n                },\n                key,\n                messageBytes\n            );\n\n            // Convert to base64 for storage/transmission\n            const encryptedArray = new Uint8Array(encryptedBuffer);\n            const encryptedBase64 = btoa(String.fromCharCode(...encryptedArray));\n            const ivBase64 = btoa(String.fromCharCode(...iv));\n\n            return {\n                encryptedData: encryptedBase64,\n                iv: ivBase64\n            };\n        } catch (error) {\n            throw new Error(`Failed to encrypt with AES: ${error.message}`);\n        }\n    }\n\n    /**\n     * Decrypt message using AES-256-GCM with Web Crypto API\n     */\n    static async decryptWithAES(encryptedData, ivB64, aesKeyHex) {\n        try {\n            // Convert base64 to Uint8Array\n            const encryptedBytes = new Uint8Array(\n                atob(encryptedData).split('').map(char => char.charCodeAt(0))\n            );\n            const iv = new Uint8Array(\n                atob(ivB64).split('').map(char => char.charCodeAt(0))\n            );\n\n            // Convert hex key to Uint8Array\n            const keyBytes = new Uint8Array(aesKeyHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));\n\n            // Import the key\n            const key = await crypto.subtle.importKey(\n                'raw',\n                keyBytes,\n                { name: 'AES-GCM' },\n                false,\n                ['decrypt']\n            );\n\n            // Decrypt the message\n            const decryptedBuffer = await crypto.subtle.decrypt(\n                {\n                    name: 'AES-GCM',\n                    iv: iv\n                },\n                key,\n                encryptedBytes\n            );\n\n            // Convert back to string\n            const decryptedMessage = new TextDecoder().decode(decryptedBuffer);\n            if (!decryptedMessage) {\n                throw new Error('AES decryption failed - invalid key or corrupted data');\n            }\n\n            return decryptedMessage;\n        } catch (error) {\n            throw new Error(`Failed to decrypt with AES: ${error.message}`);\n        }\n    }\n\n    /**\n     * Export AES key \n     */\n    static async exportAESKey(aesKeyHex) {\n        try {\n            return aesKeyHex; // Just return the hex string directly - simpler!\n        } catch (error) {\n            throw new Error(`Failed to export AES key: ${error.message}`);\n        }\n    }\n\n    /**\n     * Import AES key (accepts hex format directly for simplicity)\n     */\n    static async importAESKey(aesKeyHex) {\n        try {\n            return aesKeyHex; // Just return the hex string directly - simpler!\n        } catch (error) {\n            throw new Error(`Failed to import AES key: ${error.message}`);\n        }\n    }\n\n    /**\n     * Export RSA private key\n     */\n    static async exportPrivateKey(privateKey) {\n        try {\n            return privateKey; // Just return the PEM string directly - simpler!\n        } catch (error) {\n            throw new Error(`Failed to export private key: ${error.message}`);\n        }\n    }\n\n    /**\n     * Import RSA private key \n     */\n    static async importPrivateKey(privateKeyPem) {\n        try {\n            return privateKeyPem; // Just return the PEM string directly - simpler!\n        } catch (error) {\n            throw new Error(`Failed to import private key: ${error.message}`);\n        }\n    }\n\n    // Helper methods for Web Crypto API\n    \n    static _arrayBufferToPem(buffer, type) {\n        const base64 = btoa(String.fromCharCode(...new Uint8Array(buffer)));\n        const formatted = base64.match(/.{1,64}/g).join('\\n');\n        const pem = `-----BEGIN ${type}-----\\n${formatted}\\n-----END ${type}-----`;\n        console.log(`Generated ${type} PEM:`, pem.substring(0, 100) + '...');\n        return pem;\n    }\n    \n    static _pemToArrayBuffer(pem) {\n        console.log('Converting PEM to ArrayBuffer...');\n        \n        // Remove header/footer and all whitespace\n        const b64 = pem\n            .replace(/-----BEGIN [A-Z ]+-----/g, '')\n            .replace(/-----END [A-Z ]+-----/g, '')\n            .replace(/[\\r\\n\\s]/g, '');\n        \n        console.log('Cleaned base64 length:', b64.length);\n        console.log('Base64 sample:', b64.substring(0, 50) + '...');\n        \n        // Validate Base64 format\n        if (!/^[A-Za-z0-9+/=]+$/.test(b64)) {\n            console.error('Invalid characters found in base64:', b64.match(/[^A-Za-z0-9+/=]/g));\n            throw new Error('Invalid PEM: contains non-Base64 characters');\n        }\n        \n        try {\n            // Decode base64 to binary\n            const binary = atob(b64);\n            console.log('Binary length:', binary.length);\n            \n            // Convert to ArrayBuffer\n            const buffer = new ArrayBuffer(binary.length);\n            const view = new Uint8Array(buffer);\n            for (let i = 0; i < binary.length; i++) {\n                view[i] = binary.charCodeAt(i);\n            }\n            \n            console.log('ArrayBuffer created successfully, size:', buffer.byteLength, 'bytes');\n            return buffer;\n            \n        } catch (error) {\n            console.error('Base64 decode failed:', error);\n            throw new Error(`Failed to decode base64: ${error.message}`);\n        }\n    }\n    \n    static async _importPublicKey(publicKeyPem) {\n        console.log('Key Import Starting...');\n        console.log('PEM input length:', publicKeyPem?.length);\n        console.log('PEM starts with:', publicKeyPem?.substring(0, 30));\n        console.log('PEM ends with:', publicKeyPem?.substring(-30));\n        \n        try {\n            // Step 1: Validate PEM format\n            if (!publicKeyPem.includes('-----BEGIN PUBLIC KEY-----')) {\n                throw new Error('Invalid PEM format - missing BEGIN header');\n            }\n            if (!publicKeyPem.includes('-----END PUBLIC KEY-----')) {\n                throw new Error('Invalid PEM format - missing END header');\n            }\n            \n            // Check if this looks like a client-generated key vs backend-generated\n            console.log('🔑 Key source analysis:');\n            console.log('🔑 Contains newlines:', publicKeyPem.includes('\\n'));\n            console.log('🔑 Line count:', publicKeyPem.split('\\n').length);\n            console.log('🔑 First few lines:', publicKeyPem.split('\\n').slice(0, 3));\n            \n            // Step 2: Convert PEM to ArrayBuffer\n            console.log('Step 2: Converting PEM to ArrayBuffer...');\n            let buffer;\n            try {\n                buffer = this._pemToArrayBuffer(publicKeyPem);\n                console.log('Buffer created, length:', buffer.byteLength);\n                \n                // Validate buffer looks like SPKI (should start with 0x30 for ASN.1 SEQUENCE)\n                const firstBytes = new Uint8Array(buffer.slice(0, 10));\n                console.log('First 10 bytes:', Array.from(firstBytes).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));\n                \n                if (firstBytes[0] !== 0x30) {\n                    console.warn('Buffer does not start with ASN.1 SEQUENCE (0x30)');\n                }\n                \n            } catch (bufferError) {\n                console.error('Buffer conversion failed:', bufferError);\n                throw new Error(`PEM to buffer conversion failed: ${bufferError.message}`);\n            }\n            \n            // Step 3: Import with Web Crypto API\n            console.log('Step 3: Importing with Web Crypto API...');\n            let key;\n            try {\n                key = await crypto.subtle.importKey(\n                    'spki',\n                    buffer,\n                    {\n                        name: 'RSA-OAEP',\n                        hash: 'SHA-256'\n                    },\n                    false,\n                    ['encrypt']\n                );\n                console.log('Key imported successfully, type:', key.type, 'algorithm:', key.algorithm.name);\n            } catch (importError) {\n                console.error('Web Crypto import failed:', importError);\n                throw new Error(`Web Crypto key import failed: ${importError.message}`);\n            }\n            \n            return key;\n            \n        } catch (error) {\n            console.error('Key Import FAILED:', {\n                errorName: error.name,\n                errorMessage: error.message,\n                pemLength: publicKeyPem?.length,\n                pemPreview: publicKeyPem?.substring(0, 100)\n            });\n            throw error;\n        }\n    }\n    \n    static async _importPrivateKey(privateKeyPem) {\n        const buffer = this._pemToArrayBuffer(privateKeyPem);\n        return await crypto.subtle.importKey(\n            'pkcs8',\n            buffer,\n            {\n                name: 'RSA-OAEP',\n                hash: 'SHA-256'\n            },\n            false,\n            ['decrypt']\n        );\n    }\n    \n    // Fallback RSA key generation using JSEncrypt\n    static _generateRSAKeyPairFallback() {\n        try {\n            console.log('Using JSEncrypt fallback for key generation');\n            const jsencrypt = new JSEncrypt({ default_key_size: 2048 });\n            \n            // Generate key pair\n            const keyPair = jsencrypt.getKey();\n            \n            const publicKey = keyPair.getPublicKey();\n            const privateKey = keyPair.getPrivateKey();\n            \n            console.log('JSEncrypt key pair generated successfully');\n            \n            return {\n                publicKey: publicKey,\n                privateKey: privateKey\n            };\n        } catch (error) {\n            console.error('JSEncrypt fallback failed:', error);\n            throw new Error(`Fallback key generation failed: ${error.message}`);\n        }\n    }\n}\n\nexport default CryptoService;"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 486, "column": 0}, "map": {"version":3,"sources":["file:///Users/aviasnani/Desktop/computer%20demo/cs-demo/repo/frontend/src/services/keyExchangeService.js"],"sourcesContent":["/**\n * KeyExchangeService - Handles RSA key exchange and management with enhanced validation and caching\n * All operations now use the actual GitHub username (lowercase) instead of numeric DB IDs.\n */\n\nclass KeyExchangeService {\n  constructor() {\n    this.userKeys = new Map(); // Cache for user public keys with metadata\n    this.keyVersions = new Map(); // Track key versions for rotation\n    this.myPrivateKey = null;\n    this.myPublicKey = null;\n    this.myKeyVersion = 1;\n    this.cacheExpiry = 30 * 60 * 1000; // 30 minutes cache expiry\n    this.maxRetries = 3;\n    this.BACKEND_URL = \"http://localhost:5000\";\n  }\n\n  /**\n   * Normalize GitHub username to lowercase\n   */\n  _normalizeUsername(username) {\n    if (!username || typeof username !== 'string') {\n      throw new Error(\"GitHub username is required\");\n    }\n    return username.trim().toLowerCase();\n  }\n\n  /**\n   * Initialize keys and upload to GitHub\n   */\n  async initializeKeys(githubUsername, githubToken) {\n    githubUsername = this._normalizeUsername(githubUsername);\n    console.log(' [KEY_INIT] Starting GitHub-based key initialization for user:', githubUsername);\n\n    try {\n      const keyStorageService = (await import('./keyStorageService.js')).default;\n\n      // Try existing private key\n      const existingPrivateKey = await keyStorageService.getPrivateKey(githubUsername);\n      if (existingPrivateKey && await this.validateKeyPair(null, existingPrivateKey)) {\n        console.log(' [KEY_INIT]  Using existing private key');\n        this.myPrivateKey = existingPrivateKey;\n        return true;\n      }\n\n      // Generate new RSA key pair\n      console.log(' [KEY_INIT]  Generating new RSA key pair...');\n      const CryptoService = (await import('./cryptoService.js')).default;\n      const keyPair = await CryptoService.generateRSAKeyPair();\n\n      this.myPrivateKey = keyPair.privateKey;\n      this.myPublicKey = keyPair.publicKey;\n\n      // Store private key locally under GitHub username\n      await keyStorageService.storePrivateKey(githubUsername, this.myPrivateKey);\n      console.log(' [KEY_INIT]  Private key stored locally');\n\n      // Upload public key to GitHub\n      if (githubToken) {\n        const githubKeyService = (await import('./gitHubService.js')).default;\n        await githubKeyService.uploadPublicKey(keyPair.publicKey, githubToken);\n        console.log(' [KEY_INIT]  Public key uploaded to GitHub');\n      }\n\n      console.log('[KEY_INIT]  GitHub-based key initialization completed!');\n      return true;\n\n    } catch (error) {\n      console.error(' [KEY_INIT]  Failed to initialize keys:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get public key for a specific GitHub user from GitHub\n   */\n  async getUserPublicKey(githubUsername) {\n    githubUsername = this._normalizeUsername(githubUsername);\n    console.log(' [KEY_FETCH] Fetching public key from GitHub for:', githubUsername);\n\n    try {\n      const githubKeyService = (await import('./gitHubService.js')).default;\n\n      // Fetch SSH keys from GitHub\n      const sshKeys = await githubKeyService.fetchUserPublicKeys(githubUsername);\n      if (!sshKeys || sshKeys.length === 0) {\n        throw new Error(`No public keys found for GitHub user: ${githubUsername}`);\n      }\n\n      // Convert first SSH key to PEM format\n      const pemKey = githubKeyService.convertSSHtoPEM(sshKeys[0]);\n\n      console.log(' [KEY_FETCH]  Public key fetched from GitHub successfully');\n      return pemKey;\n\n    } catch (error) {\n      console.error('[KEY_FETCH] Failed to get GitHub public key:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all public keys for GitHub users in a room\n   */\n  async getRoomUserKeys(githubUsernames) {\n    const keys = {};\n    for (const username of githubUsernames) {\n      try {\n        keys[username] = await this.getUserPublicKey(username);\n      } catch (error) {\n        console.warn(`Failed to get key for GitHub user ${username}:`, error);\n      }\n    }\n    return keys;\n  }\n\n  getMyPrivateKey() {\n    return this.myPrivateKey;\n  }\n\n  getMyPublicKey() {\n    return this.myPublicKey;\n  }\n\n  getMyKeyVersion() {\n    return this.myKeyVersion || 1;\n  }\n\n  /**\n   * Refresh a user's public key from GitHub\n   */\n  async refreshUserKey(githubUsername) {\n    githubUsername = this._normalizeUsername(githubUsername);\n    try {\n      this.userKeys.delete(githubUsername);\n      this.keyVersions.delete(githubUsername);\n      const publicKey = await this.getUserPublicKey(githubUsername);\n      console.log(`Refreshed public key for GitHub user ${githubUsername}`);\n      return publicKey;\n    } catch (error) {\n      console.error(`Failed to refresh key for GitHub user ${githubUsername}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Validate RSA key pair\n   */\n  async validateKeyPair(publicKey, privateKey) {\n    try {\n      if (!privateKey) return false;\n      if (!this._isValidPrivateKey(privateKey)) return false;\n      if (publicKey && !this._isValidPublicKey(publicKey)) return false;\n\n      const CryptoService = (await import(\"./cryptoService.js\")).default;\n      const testData = \"key_validation_test_\" + Date.now();\n\n      try {\n        const signature = await CryptoService.signWithRSA(testData, privateKey);\n        if (!signature) return false;\n\n        if (publicKey) {\n          const isValidSignature = await CryptoService.verifyRSASignature(testData, signature, publicKey);\n          if (!isValidSignature) return false;\n\n          const encrypted = await CryptoService.encryptWithRSA(testData, publicKey);\n          const decrypted = await CryptoService.decryptWithRSA(encrypted, privateKey);\n          if (decrypted !== testData) return false;\n        }\n        return true;\n      } catch (error) {\n        console.warn(\"Key pair functional validation failed:\", error);\n        return false;\n      }\n    } catch (error) {\n      console.error(\"Key pair validation error:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Rotate keys for the current GitHub user\n   */\n  async rotateMyKeys(githubUsername, githubToken) {\n    githubUsername = this._normalizeUsername(githubUsername);\n    try {\n      console.log(`Starting key rotation for user ${githubUsername}`);\n\n      this.myPrivateKey = null;\n      this.myPublicKey = null;\n\n      const keyStorageService = (await import('./keyStorageService.js')).default;\n      await keyStorageService.clearPrivateKey(githubUsername);\n\n      await this.initializeKeys(githubUsername, githubToken);\n\n      console.log(`Key rotation completed for user ${githubUsername}`);\n      return true;\n    } catch (error) {\n      console.error(`Failed to rotate keys for user ${githubUsername}:`, error);\n      throw error;\n    }\n  }\n\n  clearCache() {\n    this.userKeys.clear();\n    this.keyVersions.clear();\n  }\n\n  async clearAllKeys() {\n    try {\n      this.clearCache();\n      const keyStorageService = (await import(\"./keyStorageService.js\")).default;\n      await keyStorageService.clearAllKeys();\n      this.myPrivateKey = null;\n      this.myPublicKey = null;\n      this.myKeyVersion = 1;\n      console.log(\"All keys cleared successfully\");\n    } catch (error) {\n      console.error(\"Failed to clear all keys:\", error);\n      throw error;\n    }\n  }\n\n  _isValidPublicKey(publicKey) {\n    if (!publicKey || typeof publicKey !== 'string') return false;\n    const pemRegex = /^-----BEGIN PUBLIC KEY-----[\\s\\S]*-----END PUBLIC KEY-----$/;\n    return pemRegex.test(publicKey.trim());\n  }\n\n  _isValidPrivateKey(privateKey) {\n    if (!privateKey || typeof privateKey !== 'string') return false;\n    const pkcs1Regex = /^-----BEGIN RSA PRIVATE KEY-----[\\s\\S]*-----END RSA PRIVATE KEY-----$/;\n    const pkcs8Regex = /^-----BEGIN PRIVATE KEY-----[\\s\\S]*-----END PRIVATE KEY-----$/;\n    return pkcs1Regex.test(privateKey.trim()) || pkcs8Regex.test(privateKey.trim());\n  }\n}\n\nconst keyExchangeService = new KeyExchangeService();\nexport default keyExchangeService;\n"],"names":[],"mappings":"AAAA;;;CAGC;;;AAED,MAAM;IACJ,aAAc;QACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,OAAO,2CAA2C;QACtE,IAAI,CAAC,WAAW,GAAG,IAAI,OAAO,kCAAkC;QAChE,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,WAAW,GAAG,KAAK,KAAK,MAAM,0BAA0B;QAC7D,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,WAAW,GAAG;IACrB;IAEA;;GAEC,GACD,mBAAmB,QAAQ,EAAE;QAC3B,IAAI,CAAC,YAAY,OAAO,aAAa,UAAU;YAC7C,MAAM,IAAI,MAAM;QAClB;QACA,OAAO,SAAS,IAAI,GAAG,WAAW;IACpC;IAEA;;GAEC,GACD,MAAM,eAAe,cAAc,EAAE,WAAW,EAAE;QAChD,iBAAiB,IAAI,CAAC,kBAAkB,CAAC;QACzC,QAAQ,GAAG,CAAC,kEAAkE;QAE9E,IAAI;YACF,MAAM,oBAAoB,CAAC,6IAAsC,EAAE,OAAO;YAE1E,2BAA2B;YAC3B,MAAM,qBAAqB,MAAM,kBAAkB,aAAa,CAAC;YACjE,IAAI,sBAAsB,MAAM,IAAI,CAAC,eAAe,CAAC,MAAM,qBAAqB;gBAC9E,QAAQ,GAAG,CAAC;gBACZ,IAAI,CAAC,YAAY,GAAG;gBACpB,OAAO;YACT;YAEA,4BAA4B;YAC5B,QAAQ,GAAG,CAAC;YACZ,MAAM,gBAAgB,CAAC,yIAAkC,EAAE,OAAO;YAClE,MAAM,UAAU,MAAM,cAAc,kBAAkB;YAEtD,IAAI,CAAC,YAAY,GAAG,QAAQ,UAAU;YACtC,IAAI,CAAC,WAAW,GAAG,QAAQ,SAAS;YAEpC,kDAAkD;YAClD,MAAM,kBAAkB,eAAe,CAAC,gBAAgB,IAAI,CAAC,YAAY;YACzE,QAAQ,GAAG,CAAC;YAEZ,8BAA8B;YAC9B,IAAI,aAAa;gBACf,MAAM,mBAAmB,CAAC,yIAAkC,EAAE,OAAO;gBACrE,MAAM,iBAAiB,eAAe,CAAC,QAAQ,SAAS,EAAE;gBAC1D,QAAQ,GAAG,CAAC;YACd;YAEA,QAAQ,GAAG,CAAC;YACZ,OAAO;QAET,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2CAA2C;YACzD,MAAM;QACR;IACF;IAEA;;GAEC,GACD,MAAM,iBAAiB,cAAc,EAAE;QACrC,iBAAiB,IAAI,CAAC,kBAAkB,CAAC;QACzC,QAAQ,GAAG,CAAC,qDAAqD;QAEjE,IAAI;YACF,MAAM,mBAAmB,CAAC,yIAAkC,EAAE,OAAO;YAErE,6BAA6B;YAC7B,MAAM,UAAU,MAAM,iBAAiB,mBAAmB,CAAC;YAC3D,IAAI,CAAC,WAAW,QAAQ,MAAM,KAAK,GAAG;gBACpC,MAAM,IAAI,MAAM,CAAC,sCAAsC,EAAE,gBAAgB;YAC3E;YAEA,sCAAsC;YACtC,MAAM,SAAS,iBAAiB,eAAe,CAAC,OAAO,CAAC,EAAE;YAE1D,QAAQ,GAAG,CAAC;YACZ,OAAO;QAET,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gDAAgD;YAC9D,MAAM;QACR;IACF;IAEA;;GAEC,GACD,MAAM,gBAAgB,eAAe,EAAE;QACrC,MAAM,OAAO,CAAC;QACd,KAAK,MAAM,YAAY,gBAAiB;YACtC,IAAI;gBACF,IAAI,CAAC,SAAS,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC;YAC/C,EAAE,OAAO,OAAO;gBACd,QAAQ,IAAI,CAAC,CAAC,kCAAkC,EAAE,SAAS,CAAC,CAAC,EAAE;YACjE;QACF;QACA,OAAO;IACT;IAEA,kBAAkB;QAChB,OAAO,IAAI,CAAC,YAAY;IAC1B;IAEA,iBAAiB;QACf,OAAO,IAAI,CAAC,WAAW;IACzB;IAEA,kBAAkB;QAChB,OAAO,IAAI,CAAC,YAAY,IAAI;IAC9B;IAEA;;GAEC,GACD,MAAM,eAAe,cAAc,EAAE;QACnC,iBAAiB,IAAI,CAAC,kBAAkB,CAAC;QACzC,IAAI;YACF,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;YACrB,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;YACxB,MAAM,YAAY,MAAM,IAAI,CAAC,gBAAgB,CAAC;YAC9C,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,gBAAgB;YACpE,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,sCAAsC,EAAE,eAAe,CAAC,CAAC,EAAE;YAC1E,MAAM;QACR;IACF;IAEA;;GAEC,GACD,MAAM,gBAAgB,SAAS,EAAE,UAAU,EAAE;QAC3C,IAAI;YACF,IAAI,CAAC,YAAY,OAAO;YACxB,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,aAAa,OAAO;YACjD,IAAI,aAAa,CAAC,IAAI,CAAC,iBAAiB,CAAC,YAAY,OAAO;YAE5D,MAAM,gBAAgB,CAAC,yIAAkC,EAAE,OAAO;YAClE,MAAM,WAAW,yBAAyB,KAAK,GAAG;YAElD,IAAI;gBACF,MAAM,YAAY,MAAM,cAAc,WAAW,CAAC,UAAU;gBAC5D,IAAI,CAAC,WAAW,OAAO;gBAEvB,IAAI,WAAW;oBACb,MAAM,mBAAmB,MAAM,cAAc,kBAAkB,CAAC,UAAU,WAAW;oBACrF,IAAI,CAAC,kBAAkB,OAAO;oBAE9B,MAAM,YAAY,MAAM,cAAc,cAAc,CAAC,UAAU;oBAC/D,MAAM,YAAY,MAAM,cAAc,cAAc,CAAC,WAAW;oBAChE,IAAI,cAAc,UAAU,OAAO;gBACrC;gBACA,OAAO;YACT,EAAE,OAAO,OAAO;gBACd,QAAQ,IAAI,CAAC,0CAA0C;gBACvD,OAAO;YACT;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,8BAA8B;YAC5C,OAAO;QACT;IACF;IAEA;;GAEC,GACD,MAAM,aAAa,cAAc,EAAE,WAAW,EAAE;QAC9C,iBAAiB,IAAI,CAAC,kBAAkB,CAAC;QACzC,IAAI;YACF,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,gBAAgB;YAE9D,IAAI,CAAC,YAAY,GAAG;YACpB,IAAI,CAAC,WAAW,GAAG;YAEnB,MAAM,oBAAoB,CAAC,6IAAsC,EAAE,OAAO;YAC1E,MAAM,kBAAkB,eAAe,CAAC;YAExC,MAAM,IAAI,CAAC,cAAc,CAAC,gBAAgB;YAE1C,QAAQ,GAAG,CAAC,CAAC,gCAAgC,EAAE,gBAAgB;YAC/D,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,+BAA+B,EAAE,eAAe,CAAC,CAAC,EAAE;YACnE,MAAM;QACR;IACF;IAEA,aAAa;QACX,IAAI,CAAC,QAAQ,CAAC,KAAK;QACnB,IAAI,CAAC,WAAW,CAAC,KAAK;IACxB;IAEA,MAAM,eAAe;QACnB,IAAI;YACF,IAAI,CAAC,UAAU;YACf,MAAM,oBAAoB,CAAC,6IAAsC,EAAE,OAAO;YAC1E,MAAM,kBAAkB,YAAY;YACpC,IAAI,CAAC,YAAY,GAAG;YACpB,IAAI,CAAC,WAAW,GAAG;YACnB,IAAI,CAAC,YAAY,GAAG;YACpB,QAAQ,GAAG,CAAC;QACd,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,MAAM;QACR;IACF;IAEA,kBAAkB,SAAS,EAAE;QAC3B,IAAI,CAAC,aAAa,OAAO,cAAc,UAAU,OAAO;QACxD,MAAM,WAAW;QACjB,OAAO,SAAS,IAAI,CAAC,UAAU,IAAI;IACrC;IAEA,mBAAmB,UAAU,EAAE;QAC7B,IAAI,CAAC,cAAc,OAAO,eAAe,UAAU,OAAO;QAC1D,MAAM,aAAa;QACnB,MAAM,aAAa;QACnB,OAAO,WAAW,IAAI,CAAC,WAAW,IAAI,OAAO,WAAW,IAAI,CAAC,WAAW,IAAI;IAC9E;AACF;AAEA,MAAM,qBAAqB,IAAI;uCAChB","debugId":null}},
    {"offset": {"line": 693, "column": 0}, "map": {"version":3,"sources":["file:///Users/aviasnani/Desktop/computer%20demo/cs-demo/repo/frontend/src/services/keyStorageService.js"],"sourcesContent":["/**\n * KeyStorageService - Secure browser key storage with validation and corruption detection\n * Handles storing/retrieving private keys in localStorage/IndexedDB with security measures\n */\n\nclass KeyStorageService {\n  constructor() {\n    this.storagePrefix = 'e2e_encryption_';\n    this.privateKeyKey = 'private_key';\n    this.publicKeyKey = 'public_key';\n    this.keyVersionKey = 'key_version';\n    this.keyTimestampKey = 'key_timestamp';\n  }\n\n  /**\n   * Store private key securely in browser storage\n   * @param {string} userId - User ID\n   * @param {string} privateKey - RSA private key in PEM format\n   * @returns {Promise<void>}\n   */\n  async storePrivateKey(userId, privateKey) {\n    try {\n      if (!userId || !privateKey) {\n        throw new Error('User ID and private key are required');\n      }\n\n      // Validate private key format\n      if (!this._isValidPrivateKey(privateKey)) {\n        throw new Error('Invalid private key format');\n      }\n\n      const keyData = {\n        privateKey,\n        timestamp: Date.now(),\n        version: 1,\n        userId\n      };\n\n      // Store in localStorage with user-specific key\n      const storageKey = this._getStorageKey(userId, this.privateKeyKey);\n      localStorage.setItem(storageKey, JSON.stringify(keyData));\n\n      console.log(`Private key stored successfully for user ${userId}`);\n    } catch (error) {\n      console.error('Failed to store private key:', error);\n      throw new Error(`Failed to store private key: ${error.message}`);\n    }\n  }\n\n  /**\n   * Retrieve private key from browser storage\n   * @param {string} userId - User ID\n   * @returns {Promise<string|null>} Private key or null if not found\n   */\n  async getPrivateKey(userId) {\n    try {\n      if (!userId) {\n        throw new Error('User ID is required');\n      }\n\n      const storageKey = this._getStorageKey(userId, this.privateKeyKey);\n      const storedData = localStorage.getItem(storageKey);\n\n      if (!storedData) {\n        return null;\n      }\n\n      const keyData = JSON.parse(storedData);\n\n      // Validate stored data structure\n      if (!keyData.privateKey || !keyData.timestamp || !keyData.userId) {\n        console.warn('Corrupted key data detected, clearing storage');\n        await this.clearPrivateKey(userId);\n        return null;\n      }\n\n      // Validate that the stored key belongs to the correct user\n      if (keyData.userId !== userId) {\n        console.warn('Key user ID mismatch, clearing storage');\n        await this.clearPrivateKey(userId);\n        return null;\n      }\n\n      // Validate private key format\n      if (!this._isValidPrivateKey(keyData.privateKey)) {\n        console.warn('Corrupted private key detected, clearing storage');\n        await this.clearPrivateKey(userId);\n        return null;\n      }\n\n      return keyData.privateKey;\n    } catch (error) {\n      console.error('Failed to retrieve private key:', error);\n      // If there's an error parsing or accessing the key, clear it\n      await this.clearPrivateKey(userId);\n      return null;\n    }\n  }\n\n  /**\n   * Clear private key from browser storage\n   * @param {string} userId - User ID\n   * @returns {Promise<void>}\n   */\n  async clearPrivateKey(userId) {\n    try {\n      if (!userId) {\n        throw new Error('User ID is required');\n      }\n\n      const storageKey = this._getStorageKey(userId, this.privateKeyKey);\n      localStorage.removeItem(storageKey);\n\n      console.log(`Private key cleared for user ${userId}`);\n    } catch (error) {\n      console.error('Failed to clear private key:', error);\n      throw new Error(`Failed to clear private key: ${error.message}`);\n    }\n  }\n\n  /**\n   * Validate stored key integrity and format\n   * @param {string} userId - User ID\n   * @returns {Promise<boolean>} True if key is valid, false otherwise\n   */\n  async validateStoredKey(userId) {\n    try {\n      const privateKey = await this.getPrivateKey(userId);\n      \n      if (!privateKey) {\n        return false;\n      }\n\n      // Additional validation: try to use the key for a test operation\n      return await this._testKeyFunctionality(privateKey);\n    } catch (error) {\n      console.error('Key validation failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all encryption keys from browser storage\n   * @returns {Promise<void>}\n   */\n  async clearAllKeys() {\n    try {\n      // Get all localStorage keys that match our prefix\n      const keysToRemove = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith(this.storagePrefix)) {\n          keysToRemove.push(key);\n        }\n      }\n\n      // Remove all matching keys\n      keysToRemove.forEach(key => {\n        localStorage.removeItem(key);\n      });\n\n      console.log(`Cleared ${keysToRemove.length} encryption keys from storage`);\n    } catch (error) {\n      console.error('Failed to clear all keys:', error);\n      throw new Error(`Failed to clear all keys: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get storage information and statistics\n   * @returns {Object} Storage information\n   */\n  getStorageInfo() {\n    try {\n      const info = {\n        storageType: 'localStorage',\n        totalKeys: 0,\n        encryptionKeys: 0,\n        storageUsed: 0,\n        isAvailable: this._isStorageAvailable()\n      };\n\n      // Count keys and calculate storage usage\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key) {\n          info.totalKeys++;\n          const value = localStorage.getItem(key);\n          info.storageUsed += key.length + (value ? value.length : 0);\n\n          if (key.startsWith(this.storagePrefix)) {\n            info.encryptionKeys++;\n          }\n        }\n      }\n\n      return info;\n    } catch (error) {\n      console.error('Failed to get storage info:', error);\n      return {\n        storageType: 'localStorage',\n        totalKeys: 0,\n        encryptionKeys: 0,\n        storageUsed: 0,\n        isAvailable: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Store public key for caching purposes\n   * @param {string} userId - User ID\n   * @param {string} publicKey - RSA public key in PEM format\n   * @returns {Promise<void>}\n   */\n  async storePublicKey(userId, publicKey) {\n    try {\n      if (!userId || !publicKey) {\n        throw new Error('User ID and public key are required');\n      }\n\n      const keyData = {\n        publicKey,\n        timestamp: Date.now(),\n        userId\n      };\n\n      const storageKey = this._getStorageKey(userId, this.publicKeyKey);\n      localStorage.setItem(storageKey, JSON.stringify(keyData));\n    } catch (error) {\n      console.error('Failed to store public key:', error);\n      // Don't throw error for public key storage failures\n    }\n  }\n\n  /**\n   * Retrieve cached public key\n   * @param {string} userId - User ID\n   * @returns {Promise<string|null>} Public key or null if not found\n   */\n  async getPublicKey(userId) {\n    try {\n      if (!userId) {\n        return null;\n      }\n\n      const storageKey = this._getStorageKey(userId, this.publicKeyKey);\n      const storedData = localStorage.getItem(storageKey);\n\n      if (!storedData) {\n        return null;\n      }\n\n      const keyData = JSON.parse(storedData);\n      return keyData.publicKey || null;\n    } catch (error) {\n      console.error('Failed to retrieve public key:', error);\n      return null;\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Generate storage key with prefix and user ID\n   * @param {string} userId - User ID\n   * @param {string} keyType - Type of key (private_key, public_key, etc.)\n   * @returns {string} Storage key\n   */\n  _getStorageKey(userId, keyType) {\n    return `${this.storagePrefix}${userId}_${keyType}`;\n  }\n\n  /**\n   * Validate private key format (basic PEM format check)\n   * @param {string} privateKey - Private key to validate\n   * @returns {boolean} True if valid format\n   */\n  _isValidPrivateKey(privateKey) {\n    if (!privateKey || typeof privateKey !== 'string') {\n      return false;\n    }\n\n    // Check for both PKCS#1 and PKCS#8 private key PEM formats\n    const pkcs1Regex = /^-----BEGIN RSA PRIVATE KEY-----[\\s\\S]*-----END RSA PRIVATE KEY-----$/;\n    const pkcs8Regex = /^-----BEGIN PRIVATE KEY-----[\\s\\S]*-----END PRIVATE KEY-----$/;\n    \n    return pkcs1Regex.test(privateKey.trim()) || pkcs8Regex.test(privateKey.trim());\n  }\n\n  /**\n   * Test key functionality by performing a simple operation\n   * @param {string} privateKey - Private key to test\n   * @returns {Promise<boolean>} True if key works\n   */\n  async _testKeyFunctionality(privateKey) {\n    try {\n      // Import CryptoService dynamically to avoid circular dependencies\n      const CryptoService = (await import('./cryptoService')).default;\n      \n      // Try to generate a signature with the private key\n      const testData = 'test_key_validation';\n      const signature = await CryptoService.signWithRSA(testData, privateKey);\n      \n      // If we got a signature, the key is functional\n      return !!signature;\n    } catch (error) {\n      console.warn('Key functionality test failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Check if localStorage is available\n   * @returns {boolean} True if storage is available\n   */\n  _isStorageAvailable() {\n    try {\n      const test = '__storage_test__';\n      localStorage.setItem(test, test);\n      localStorage.removeItem(test);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n}\n\n// Export singleton instance\nconst keyStorageService = new KeyStorageService();\nexport default keyStorageService;"],"names":[],"mappings":"AAAA;;;CAGC;;;AAED,MAAM;IACJ,aAAc;QACZ,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,eAAe,GAAG;IACzB;IAEA;;;;;GAKC,GACD,MAAM,gBAAgB,MAAM,EAAE,UAAU,EAAE;QACxC,IAAI;YACF,IAAI,CAAC,UAAU,CAAC,YAAY;gBAC1B,MAAM,IAAI,MAAM;YAClB;YAEA,8BAA8B;YAC9B,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,aAAa;gBACxC,MAAM,IAAI,MAAM;YAClB;YAEA,MAAM,UAAU;gBACd;gBACA,WAAW,KAAK,GAAG;gBACnB,SAAS;gBACT;YACF;YAEA,+CAA+C;YAC/C,MAAM,aAAa,IAAI,CAAC,cAAc,CAAC,QAAQ,IAAI,CAAC,aAAa;YACjE,aAAa,OAAO,CAAC,YAAY,KAAK,SAAS,CAAC;YAEhD,QAAQ,GAAG,CAAC,CAAC,yCAAyC,EAAE,QAAQ;QAClE,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,MAAM,OAAO,EAAE;QACjE;IACF;IAEA;;;;GAIC,GACD,MAAM,cAAc,MAAM,EAAE;QAC1B,IAAI;YACF,IAAI,CAAC,QAAQ;gBACX,MAAM,IAAI,MAAM;YAClB;YAEA,MAAM,aAAa,IAAI,CAAC,cAAc,CAAC,QAAQ,IAAI,CAAC,aAAa;YACjE,MAAM,aAAa,aAAa,OAAO,CAAC;YAExC,IAAI,CAAC,YAAY;gBACf,OAAO;YACT;YAEA,MAAM,UAAU,KAAK,KAAK,CAAC;YAE3B,iCAAiC;YACjC,IAAI,CAAC,QAAQ,UAAU,IAAI,CAAC,QAAQ,SAAS,IAAI,CAAC,QAAQ,MAAM,EAAE;gBAChE,QAAQ,IAAI,CAAC;gBACb,MAAM,IAAI,CAAC,eAAe,CAAC;gBAC3B,OAAO;YACT;YAEA,2DAA2D;YAC3D,IAAI,QAAQ,MAAM,KAAK,QAAQ;gBAC7B,QAAQ,IAAI,CAAC;gBACb,MAAM,IAAI,CAAC,eAAe,CAAC;gBAC3B,OAAO;YACT;YAEA,8BAA8B;YAC9B,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,UAAU,GAAG;gBAChD,QAAQ,IAAI,CAAC;gBACb,MAAM,IAAI,CAAC,eAAe,CAAC;gBAC3B,OAAO;YACT;YAEA,OAAO,QAAQ,UAAU;QAC3B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mCAAmC;YACjD,6DAA6D;YAC7D,MAAM,IAAI,CAAC,eAAe,CAAC;YAC3B,OAAO;QACT;IACF;IAEA;;;;GAIC,GACD,MAAM,gBAAgB,MAAM,EAAE;QAC5B,IAAI;YACF,IAAI,CAAC,QAAQ;gBACX,MAAM,IAAI,MAAM;YAClB;YAEA,MAAM,aAAa,IAAI,CAAC,cAAc,CAAC,QAAQ,IAAI,CAAC,aAAa;YACjE,aAAa,UAAU,CAAC;YAExB,QAAQ,GAAG,CAAC,CAAC,6BAA6B,EAAE,QAAQ;QACtD,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,MAAM,OAAO,EAAE;QACjE;IACF;IAEA;;;;GAIC,GACD,MAAM,kBAAkB,MAAM,EAAE;QAC9B,IAAI;YACF,MAAM,aAAa,MAAM,IAAI,CAAC,aAAa,CAAC;YAE5C,IAAI,CAAC,YAAY;gBACf,OAAO;YACT;YAEA,iEAAiE;YACjE,OAAO,MAAM,IAAI,CAAC,qBAAqB,CAAC;QAC1C,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,0BAA0B;YACxC,OAAO;QACT;IACF;IAEA;;;GAGC,GACD,MAAM,eAAe;QACnB,IAAI;YACF,kDAAkD;YAClD,MAAM,eAAe,EAAE;YACvB,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,MAAM,EAAE,IAAK;gBAC5C,MAAM,MAAM,aAAa,GAAG,CAAC;gBAC7B,IAAI,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,aAAa,GAAG;oBAC7C,aAAa,IAAI,CAAC;gBACpB;YACF;YAEA,2BAA2B;YAC3B,aAAa,OAAO,CAAC,CAAA;gBACnB,aAAa,UAAU,CAAC;YAC1B;YAEA,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,aAAa,MAAM,CAAC,6BAA6B,CAAC;QAC3E,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,MAAM,OAAO,EAAE;QAC9D;IACF;IAEA;;;GAGC,GACD,iBAAiB;QACf,IAAI;YACF,MAAM,OAAO;gBACX,aAAa;gBACb,WAAW;gBACX,gBAAgB;gBAChB,aAAa;gBACb,aAAa,IAAI,CAAC,mBAAmB;YACvC;YAEA,yCAAyC;YACzC,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,MAAM,EAAE,IAAK;gBAC5C,MAAM,MAAM,aAAa,GAAG,CAAC;gBAC7B,IAAI,KAAK;oBACP,KAAK,SAAS;oBACd,MAAM,QAAQ,aAAa,OAAO,CAAC;oBACnC,KAAK,WAAW,IAAI,IAAI,MAAM,GAAG,CAAC,QAAQ,MAAM,MAAM,GAAG,CAAC;oBAE1D,IAAI,IAAI,UAAU,CAAC,IAAI,CAAC,aAAa,GAAG;wBACtC,KAAK,cAAc;oBACrB;gBACF;YACF;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,OAAO;gBACL,aAAa;gBACb,WAAW;gBACX,gBAAgB;gBAChB,aAAa;gBACb,aAAa;gBACb,OAAO,MAAM,OAAO;YACtB;QACF;IACF;IAEA;;;;;GAKC,GACD,MAAM,eAAe,MAAM,EAAE,SAAS,EAAE;QACtC,IAAI;YACF,IAAI,CAAC,UAAU,CAAC,WAAW;gBACzB,MAAM,IAAI,MAAM;YAClB;YAEA,MAAM,UAAU;gBACd;gBACA,WAAW,KAAK,GAAG;gBACnB;YACF;YAEA,MAAM,aAAa,IAAI,CAAC,cAAc,CAAC,QAAQ,IAAI,CAAC,YAAY;YAChE,aAAa,OAAO,CAAC,YAAY,KAAK,SAAS,CAAC;QAClD,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,oDAAoD;QACtD;IACF;IAEA;;;;GAIC,GACD,MAAM,aAAa,MAAM,EAAE;QACzB,IAAI;YACF,IAAI,CAAC,QAAQ;gBACX,OAAO;YACT;YAEA,MAAM,aAAa,IAAI,CAAC,cAAc,CAAC,QAAQ,IAAI,CAAC,YAAY;YAChE,MAAM,aAAa,aAAa,OAAO,CAAC;YAExC,IAAI,CAAC,YAAY;gBACf,OAAO;YACT;YAEA,MAAM,UAAU,KAAK,KAAK,CAAC;YAC3B,OAAO,QAAQ,SAAS,IAAI;QAC9B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,kCAAkC;YAChD,OAAO;QACT;IACF;IAEA,yBAAyB;IAEzB;;;;;GAKC,GACD,eAAe,MAAM,EAAE,OAAO,EAAE;QAC9B,OAAO,GAAG,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,EAAE,SAAS;IACpD;IAEA;;;;GAIC,GACD,mBAAmB,UAAU,EAAE;QAC7B,IAAI,CAAC,cAAc,OAAO,eAAe,UAAU;YACjD,OAAO;QACT;QAEA,2DAA2D;QAC3D,MAAM,aAAa;QACnB,MAAM,aAAa;QAEnB,OAAO,WAAW,IAAI,CAAC,WAAW,IAAI,OAAO,WAAW,IAAI,CAAC,WAAW,IAAI;IAC9E;IAEA;;;;GAIC,GACD,MAAM,sBAAsB,UAAU,EAAE;QACtC,IAAI;YACF,kEAAkE;YAClE,MAAM,gBAAgB,CAAC,yIAA+B,EAAE,OAAO;YAE/D,mDAAmD;YACnD,MAAM,WAAW;YACjB,MAAM,YAAY,MAAM,cAAc,WAAW,CAAC,UAAU;YAE5D,+CAA+C;YAC/C,OAAO,CAAC,CAAC;QACX,EAAE,OAAO,OAAO;YACd,QAAQ,IAAI,CAAC,kCAAkC;YAC/C,OAAO;QACT;IACF;IAEA;;;GAGC,GACD,sBAAsB;QACpB,IAAI;YACF,MAAM,OAAO;YACb,aAAa,OAAO,CAAC,MAAM;YAC3B,aAAa,UAAU,CAAC;YACxB,OAAO;QACT,EAAE,OAAO,OAAO;YACd,OAAO;QACT;IACF;AACF;AAEA,4BAA4B;AAC5B,MAAM,oBAAoB,IAAI;uCACf","debugId":null}},
    {"offset": {"line": 980, "column": 0}, "map": {"version":3,"sources":["file:///Users/aviasnani/Desktop/computer%20demo/cs-demo/repo/frontend/src/services/encryptionService.js"],"sourcesContent":["/**\n * EncryptionService - High-level message encryption orchestration service\n * Orchestrates complete encrypt/decrypt message flow with error handling and graceful degradation\n */\n\nimport CryptoService from './cryptoService';\nimport keyExchangeService from './keyExchangeService';\nimport keyStorageService from './keyStorageService';\n\n// Encryption error types\nexport const EncryptionErrorTypes = {\n  KEY_GENERATION_FAILED: 'key_generation_failed',\n  ENCRYPTION_FAILED: 'encryption_failed',\n  DECRYPTION_FAILED: 'decryption_failed',\n  KEY_EXCHANGE_FAILED: 'key_exchange_failed',\n  SIGNATURE_VERIFICATION_FAILED: 'signature_verification_failed',\n  STORAGE_FAILED: 'storage_failed',\n  INITIALIZATION_FAILED: 'initialization_failed'\n};\n\n// Encryption status interface\nexport const EncryptionStatus = {\n  AVAILABLE: 'available',\n  UNAVAILABLE: 'unavailable',\n  INITIALIZING: 'initializing',\n  ERROR: 'error'\n};\n\nclass EncryptionService {\n  constructor() {\n    this.isInitialized = false;\n    this.currentUserId = null;\n    this.currentToken = null;\n    this.lastError = null;\n    this.keyGenerationTime = null;\n    this.initializationPromise = null;\n  }\n\n  /**\n   * Initialize encryption service for the current user\n   * @param {string} userId - Current user ID\n   * @param {string} token - Authentication token\n   * @returns {Promise<boolean>} True if initialization successful\n   */\n  async initialize(userId, token) {\n    try {\n      // Prevent multiple simultaneous initializations\n      if (this.initializationPromise) {\n        return await this.initializationPromise;\n      }\n\n      this.initializationPromise = this._performInitialization(userId, token);\n      const result = await this.initializationPromise;\n      this.initializationPromise = null;\n      \n      return result;\n    } catch (error) {\n      this.initializationPromise = null;\n      throw error;\n    }\n  }\n\n  /**\n   * Encrypt a message for sending to a specific recipient\n   * @param {string} message - Plain text message to encrypt\n   * @param {string} recipientGithubUsername - Recipient's user ID\n   * @returns {Promise<EncryptedMessageData>} Encrypted message data\n   */\n  async encryptMessage(message, recipientGithubUsername) {\n    console.log('[ENCRYPTION] Starting message encryption process');\n    console.log('[ENCRYPTION] Message length:', message.length, 'characters');\n    console.log('[ENCRYPTION] Recipient username:', recipientGithubUsername);\n    \n    try {\n      // Basic validation\n      if (!message || typeof message !== 'string') {\n        console.error(' [ENCRYPTION] Invalid message format');\n        throw new Error('Invalid message format');\n      }\n\n      if (!recipientGithubUsername) {\n        console.error(' [ENCRYPTION]  Recipient Github username  is required');\n        throw new Error('Recipient github username is required');\n      }\n\n      if (!this.isEncryptionAvailable()) {\n        console.error('[ENCRYPTION]  Encryption not available');\n        throw new Error('Encryption not available');\n      }\n\n      console.log('[ENCRYPTION]  Pre-flight checks passed');\n\n      // REAL RSA PUBLIC-PRIVATE KEY ENCRYPTION\n      console.log('ENCRYPTION: Using REAL RSA public-private key encryption');\n      \n      // Get recipient's public key with FRESH fetch\n      let recipientKeyData;\n      try {\n        recipientKeyData = await this._getRecipientPublicKey(recipientGithubUsername);\n        console.log('ENCRYPTION: Got FRESH recipient public key, ID:', recipientKeyData.keyId);\n      } catch (error) {\n        console.error('ENCRYPTION: No recipient public key, sending plain text');\n        return {\n          content: message,\n          encrypted_aes_key: null,\n          iv: null,\n          signature: null,\n          is_encrypted: false,\n          sender_id: this.currentUserId\n        };\n      }\n      \n      // Generate AES key for this message\n      const aesKey = await CryptoService.generateAESKey();\n      console.log('ENCRYPTION: Generated AES key');\n      \n      // Encrypt message with AES\n      const encryptedMessage = await CryptoService.encryptWithAES(message, aesKey);\n      console.log('ENCRYPTION: Message encrypted with AES');\n      \n      // Encrypt AES key with recipient's PUBLIC key (RSA)\n      const encryptedAESKey = await this._encryptWithPublicKey(aesKey, recipientKeyData.publicKey);\n      console.log('ENCRYPTION: AES key encrypted with recipient\\'s PUBLIC key, ID:', recipientKeyData.keyId);\n      \n      // Sign message with our PRIVATE key\n      const myPrivateKey = await this._getMyPrivateKey();\n      const signature = await this._signWithPrivateKey(message, myPrivateKey);\n      console.log('ENCRYPTION: Message signed with our PRIVATE key');\n\n      const encryptedData = {\n        content: encryptedMessage.encryptedData,\n        encrypted_aes_key: encryptedAESKey,\n        iv: encryptedMessage.iv,\n        signature: signature,\n        is_encrypted: true,\n        sender_id: this.currentUserId,\n        recipient_key_id: recipientKeyData.keyId,\n        intended_recipient: recipientGithubUsername\n      };\n\n      console.log('ENCRYPTION: REAL RSA encryption completed!');\n      this.lastError = null;\n      return encryptedData;\n      // Real encryption code above\n\n    } catch (error) {\n      this.lastError = this._createErrorInfo(EncryptionErrorTypes.ENCRYPTION_FAILED, error);\n      throw this.lastError;\n    }\n  }\n\n  /**\n   * Decrypt a received message\n   * @param {EncryptedMessageData} encryptedData - Encrypted message data\n   * @param {string} senderUserId - Sender's user ID for signature verification\n   * @returns {Promise<string>} Decrypted plain text message\n   */\n  async decryptMessage(encryptedData, senderUserId) {\n    console.log('[DECRYPTION] Starting message decryption process');\n    console.log('[DECRYPTION] Sender ID:', senderUserId);\n    console.log('DECRYPTION] Is encrypted:', encryptedData?.is_encrypted);\n    \n    try {\n      if (!encryptedData) {\n        console.error('[DECRYPTION]  No encrypted data provided');\n        throw new Error('No encrypted data provided');\n      }\n\n      // If message is not encrypted, return as-is\n      if (!encryptedData.is_encrypted) {\n        console.log('DECRYPTION: Message is not encrypted, returning as-is');\n        return encryptedData.content;\n      }\n\n      if (!this.isEncryptionAvailable()) {\n        console.error('DECRYPTION: Encryption not available for decryption');\n        throw new Error('Encryption not available for decryption');\n      }\n\n      console.log('DECRYPTION: Starting real message decryption');\n      console.log('DECRYPTION: Full encrypted data:', {\n        sender_id: encryptedData.sender_id,\n        is_encrypted: encryptedData.is_encrypted,\n        has_aes_key: !!encryptedData.encrypted_aes_key,\n        has_iv: !!encryptedData.iv\n      });\n\n      // Decrypt AES key with our private key\n      console.log('DECRYPTION: Decrypting AES key with RSA private key...');\n      console.log('DECRYPTION: Encrypted AES key length:', encryptedData.encrypted_aes_key?.length);\n      console.log('DECRYPTION: Message sender:', senderUserId);\n      console.log('DECRYPTION: Current user:', this.currentUserId);\n      console.log('DECRYPTION: Message sender_id from data:', encryptedData.sender_id);\n      \n      // Check if this message was sent by us\n      if (encryptedData.sender_id === this.currentUserId) {\n        console.log('DECRYPTION: This is our own message - showing as sent');\n        return '[Your encrypted message]';\n      }\n      \n      // Verify this message was intended for us\n      if (encryptedData.intended_recipient && encryptedData.intended_recipient !== this.currentUserId) {\n        console.error('DECRYPTION: Message not intended for us. Intended for:', encryptedData.intended_recipient);\n        throw new Error('Message was not encrypted for this user');\n      }\n      \n      // Get our current key ID for verification\n      const myPublicKey = keyExchangeService.getMyPublicKey();\n      const myKeyVersion = keyExchangeService.getMyKeyVersion();\n      const myKeyId = `${this.currentUserId}_v${myKeyVersion}`;\n      \n      console.log('DECRYPTION: Our key ID:', myKeyId);\n      console.log('DECRYPTION: Message encrypted with key ID:', encryptedData.recipient_key_id);\n      \n      if (encryptedData.recipient_key_id && encryptedData.recipient_key_id !== myKeyId) {\n        console.warn('DECRYPTION: Key ID mismatch - message encrypted with different key version');\n        console.warn('DECRYPTION: Expected:', myKeyId, 'Got:', encryptedData.recipient_key_id);\n      }\n      \n      // REAL RSA PUBLIC-PRIVATE KEY DECRYPTION\n      console.log('DECRYPTION: Using REAL RSA private key decryption');\n      \n      // Decrypt AES key with our PRIVATE key (RSA)\n      const myPrivateKey = await this._getMyPrivateKey();\n      console.log('DECRYPTION: Got our private key');\n      \n      let aesKey;\n      try {\n        aesKey = await this._decryptWithPrivateKey(encryptedData.encrypted_aes_key, myPrivateKey);\n        console.log('DECRYPTION: AES key decrypted with our PRIVATE key');\n      } catch (rsaError) {\n        throw new Error('Cannot decrypt: message was not encrypted for this user');\n      }\n      \n      // Decrypt message content with AES key\n      console.log('DECRYPTION: Decrypting message content with AES...');\n      const decryptedMessage = await CryptoService.decryptWithAES(\n        encryptedData.content,\n        encryptedData.iv,\n        aesKey\n      );\n      console.log('DECRYPTION: Message decrypted successfully!');\n      \n      // Verify signature with sender's PUBLIC key\n      if (encryptedData.signature && senderUserId) {\n        console.log('DECRYPTION: Verifying signature with sender\\'s PUBLIC key...');\n        const senderPublicKey = await this._getRecipientPublicKey(senderUserId);\n        const isValid = await this._verifyWithPublicKey(decryptedMessage, encryptedData.signature, senderPublicKey.publicKey);\n        if (!isValid) {\n          console.warn('DECRYPTION: Signature verification failed!');\n        } else {\n          console.log('DECRYPTION: Signature verified - message is authentic!');\n        }\n      }\n      \n      return decryptedMessage;\n\n\n\n    } catch (error) {\n      // Preserve signature verification error type\n      if (error.type === EncryptionErrorTypes.SIGNATURE_VERIFICATION_FAILED) {\n        this.lastError = this._createErrorInfo(EncryptionErrorTypes.SIGNATURE_VERIFICATION_FAILED, error);\n      } else {\n        this.lastError = this._createErrorInfo(EncryptionErrorTypes.DECRYPTION_FAILED, error);\n      }\n      \n      throw this.lastError;\n    }\n  }\n\n  /**\n   * Decrypt a message without signature verification (for fallback scenarios)\n   * @param {EncryptedMessageData} encryptedData - Encrypted message data\n   * @returns {Promise<string>} Decrypted plain text message\n   */\n  async decryptMessageWithoutSignature(encryptedData) {\n    try {\n      if (!encryptedData) {\n        throw new Error('No encrypted data provided');\n      }\n\n      // If message is not encrypted, return as-is\n      if (!encryptedData.is_encrypted) {\n        return encryptedData.content;\n      }\n\n      if (!this.isEncryptionAvailable()) {\n        throw new Error('Encryption not available for decryption');\n      }\n\n      // Decrypt AES key with our private key\n      const myPrivateKey = await this._getMyPrivateKey();\n      const aesKey = await CryptoService.decryptWithRSA(\n        encryptedData.encrypted_aes_key, \n        myPrivateKey\n      );\n      \n      // Decrypt message content with AES key\n      const decryptedMessage = await CryptoService.decryptWithAES(\n        encryptedData.content,\n        encryptedData.iv,\n        aesKey\n      );\n\n      this.lastError = null;\n      return decryptedMessage;\n\n    } catch (error) {\n      console.error('Message decryption (without signature) failed:', error);\n      this.lastError = this._createErrorInfo(EncryptionErrorTypes.DECRYPTION_FAILED, error);\n      throw this.lastError;\n    }\n  }\n\n  /**\n   * Check if encryption is available\n   * @returns {boolean} True if encryption is available\n   */\n  isEncryptionAvailable() {\n    return this.isInitialized && \n           this.currentUserId && \n           this.currentToken &&\n           keyExchangeService.getMyPrivateKey() !== null;\n  }\n\n  /**\n   * Get current encryption status\n   * @returns {Object} Encryption status information\n   */\n  getEncryptionStatus() {\n    const hasPrivateKey = keyExchangeService.getMyPrivateKey() !== null;\n    const hasPublicKey = keyExchangeService.getMyPublicKey() !== null;\n\n    let status = EncryptionStatus.UNAVAILABLE;\n    if (this.initializationPromise) {\n      status = EncryptionStatus.INITIALIZING;\n    } else if (this.isEncryptionAvailable()) {\n      status = EncryptionStatus.AVAILABLE;\n    } else if (this.lastError) {\n      status = EncryptionStatus.ERROR;\n    }\n\n    return {\n      status,\n      isAvailable: this.isEncryptionAvailable(),\n      keysInitialized: hasPrivateKey && hasPublicKey,\n      lastError: this.lastError,\n      keyGenerationTime: this.keyGenerationTime,\n      userId: this.currentUserId\n    };\n  }\n\n  /**\n   * Handle encryption errors with user-friendly messages\n   * @param {Error} error - The error that occurred\n   * @returns {Object} Error information object\n   */\n  handleEncryptionError(error) {\n    return this._createErrorInfo(EncryptionErrorTypes.ENCRYPTION_FAILED, error);\n  }\n\n  /**\n   * Clear encryption state and keys (for logout)\n   * @returns {Promise<void>}\n   */\n  async clearEncryption() {\n    try {\n      if (this.currentUserId) {\n        await keyStorageService.clearPrivateKey(this.currentUserId);\n      }\n      \n      keyExchangeService.clearCache();\n      \n      this.isInitialized = false;\n      this.currentUserId = null;\n      this.currentToken = null;\n      this.lastError = null;\n      this.keyGenerationTime = null;\n      \n      console.log('Encryption state cleared');\n    } catch (error) {\n      console.error('Failed to clear encryption state:', error);\n    }\n  }\n\n  /**\n   * Refresh encryption keys (regenerate and re-upload)\n   * @returns {Promise<boolean>} True if refresh successful\n   */\n  async refreshKeys() {\n    try {\n      if (!this.currentUserId || !this.currentToken) {\n        throw new Error('User not initialized');\n      }\n\n      // Clear existing keys\n      await keyStorageService.clearPrivateKey(this.currentUserId);\n      keyExchangeService.clearCache();\n\n      // Re-initialize with new keys\n      return await this.initialize(this.currentUserId, this.currentToken);\n    } catch (error) {\n      console.error('Failed to refresh keys:', error);\n      this.lastError = this._createErrorInfo(EncryptionErrorTypes.KEY_GENERATION_FAILED, error);\n      return false;\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Perform the actual initialization process\n   * @param {string} userId - User ID\n   * @param {string} token - Authentication token\n   * @returns {Promise<boolean>} True if successful\n   */\n  async _performInitialization(userId, token) {\n    console.log('INIT: Starting encryption service initialization');\n    console.log('INIT: User ID:', userId);\n    \n    try {\n      this.currentUserId = userId;\n      this.currentToken = token;\n\n      // Try to load existing private key from storage\n      console.log('INIT: Checking for existing private key...');\n      let privateKey = await keyStorageService.getPrivateKey(userId);\n      let publicKey = null;\n\n      if (privateKey) {\n        console.log('INIT: Found existing private key, validating...');\n        const isValid = await keyStorageService.validateStoredKey(userId);\n        if (!isValid) {\n          console.warn('INIT: Stored key is invalid, generating new keys');\n          privateKey = null;\n        } else {\n          console.log('INIT: Existing private key is valid');\n        }\n      } else {\n        console.log('INIT: No existing private key found');\n      }\n\n      if (!privateKey) {\n        console.log('INIT: Generating new RSA-2048 key pair...');\n        const keyPair = await CryptoService.generateRSAKeyPair();\n        privateKey = keyPair.privateKey;\n        publicKey = keyPair.publicKey;\n        console.log('INIT: RSA key pair generated successfully');\n        \n        // Store private key securely\n        console.log('INIT: Storing private key securely...');\n        await keyStorageService.storePrivateKey(userId, privateKey);\n        console.log('INIT: Private key stored securely');\n        \n        this.keyGenerationTime = new Date();\n      }\n\n      // Initialize key exchange service\n      console.log('INIT: Initializing key exchange service...');\n      await keyExchangeService.initializeKeys(userId, token);\n      console.log('INIT: Key exchange service initialized');\n\n      this.isInitialized = true;\n      this.lastError = null;\n      \n      console.log('INIT: EncryptionService initialized successfully!');\n      console.log('INIT: End-to-end encryption is now ACTIVE');\n      return true;\n\n    } catch (error) {\n      console.error('INIT: EncryptionService initialization failed:', error);\n      this.lastError = this._createErrorInfo(EncryptionErrorTypes.INITIALIZATION_FAILED, error);\n      this.isInitialized = false;\n      throw error;\n    }\n  }\n\n  /**\n   * Get recipient's public key with FRESH retrieval and key ID\n   * @param {string} recipientUserId - Recipient's user ID\n   * @returns {Promise<{publicKey: string, keyId: string}>} Public key with ID\n   */\n  async _getRecipientPublicKey(recipientGithubUsername) {\n    console.log('KEY_EXCHANGE: FRESH fetch of public key for recipient:', recipientGithubUsername);\n    \n      try {\n        // Directly fetch PEM from GitHub via keyExchangeService\n        const pemKey = await keyExchangeService.getUserPublicKey(recipientGithubUsername);\n\n        // Wrap with a default key version (you can enhance this later if you want rotation)\n        return {\n            publicKey: pemKey,\n            keyId: `${recipientGithubUsername}_v1`\n        };\n    } catch (error) {\n        console.error('KEY_EXCHANGE: Failed to fetch public key from GitHub:', error.message);\n        throw new Error(`Cannot fetch public key for ${recipientGithubUsername}`);\n    }\n  }\n\n  /**\n   * Get current user's private key\n   * @returns {Promise<string>} Private key\n   */\n  async _getMyPrivateKey() {\n    const privateKey = keyExchangeService.getMyPrivateKey();\n    if (!privateKey) {\n      throw new Error('Private key not available');\n    }\n    return privateKey;\n  }\n\n  /**\n   * Generate a deterministic room key for two users\n   * @param {string} userId1 - First user ID\n   * @param {string} userId2 - Second user ID\n   * @returns {Promise<string>} Room key in hex format\n   */\n  async _generateRoomKey(userId1, userId2) {\n    // Create deterministic key based on both user IDs\n    const sortedIds = [userId1, userId2].sort();\n    const keyString = `room_key_${sortedIds[0]}_${sortedIds[1]}_secret`;\n    \n    console.log('ROOM_KEY: Generating key for users:', userId1, 'and', userId2);\n    console.log('ROOM_KEY: Sorted IDs:', sortedIds);\n    console.log('ROOM_KEY: Key string:', keyString);\n    \n    // Generate SHA-256 hash and convert to hex\n    const encoder = new TextEncoder();\n    const data = encoder.encode(keyString);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = new Uint8Array(hashBuffer);\n    \n    const roomKey = Array.from(hashArray).map(b => b.toString(16).padStart(2, '0')).join('');\n    console.log('ROOM_KEY: Generated key length:', roomKey.length);\n    console.log('ROOM_KEY: Generated key preview:', roomKey.substring(0, 20) + '...');\n    \n    return roomKey;\n  }\n\n  /**\n   * Verify message signature\n   * @param {string} message - Original message\n   * @param {string} signature - Message signature\n   * @param {string} senderUserId - Sender's user ID\n   * @returns {Promise<boolean>} True if signature is valid\n   */\n  async _verifyMessageSignature(message, signature, senderUserId) {\n    console.log('[SIGNATURE] Verifying message signature from sender:', senderUserId);\n    \n    try {\n      console.log('[SIGNATURE] Getting sender public key for verification...');\n      const senderPublicKey = await this._getRecipientPublicKey(senderUserId);\n      console.log('[SIGNATURE]  Sender public key obtained');\n      \n      console.log('[SIGNATURE] Verifying RSA signature...');\n      const isValid = await CryptoService.verifyRSASignature(message, signature, senderPublicKey);\n      \n      if (!isValid) {\n        console.warn('[SIGNATURE]  Signature verification failed for message from', senderUserId);\n        this.lastError = this._createErrorInfo(EncryptionErrorTypes.SIGNATURE_VERIFICATION_FAILED, \n          new Error('Message signature verification failed'));\n      } else {\n        console.log(' [SIGNATURE]  Signature verification successful - message is authentic');\n      }\n      \n      return isValid;\n    } catch (error) {\n      console.error(' [SIGNATURE]  Signature verification error:', error);\n      this.lastError = this._createErrorInfo(EncryptionErrorTypes.SIGNATURE_VERIFICATION_FAILED, error);\n      return false;\n    }\n  }\n\n  /**\n   * Create standardized error information object\n   * @param {string} type - Error type from EncryptionErrorTypes\n   * @param {Error} error - Original error\n   * @returns {Object} Error information object\n   */\n  _createErrorInfo(type, error) {\n    return {\n      type,\n      message: error.message,\n      timestamp: new Date(),\n      userFriendlyMessage: this._getUserFriendlyErrorMessage(type, error)\n    };\n  }\n\n  /**\n   * Get user-friendly error message\n   * @param {string} type - Error type\n   * @param {Error} error - Original error\n   * @returns {string} User-friendly error message\n   */\n  _getUserFriendlyErrorMessage(type, error) {\n    switch (type) {\n      case EncryptionErrorTypes.KEY_GENERATION_FAILED:\n        return 'Failed to generate encryption keys. Please try again.';\n      case EncryptionErrorTypes.ENCRYPTION_FAILED:\n        return 'Failed to encrypt message. Please check your connection and try again.';\n      case EncryptionErrorTypes.DECRYPTION_FAILED:\n        return 'Unable to decrypt this message. It may be corrupted or sent with incompatible encryption.';\n      case EncryptionErrorTypes.KEY_EXCHANGE_FAILED:\n        return 'Failed to exchange encryption keys. Please refresh and try again.';\n      case EncryptionErrorTypes.SIGNATURE_VERIFICATION_FAILED:\n        return 'Message authenticity could not be verified. This message may not be from the claimed sender.';\n      case EncryptionErrorTypes.STORAGE_FAILED:\n        return 'Failed to store encryption keys securely. Please check your browser settings.';\n      case EncryptionErrorTypes.INITIALIZATION_FAILED:\n        return 'Failed to initialize encryption. Please refresh the page and try again.';\n      default:\n        return 'An encryption error occurred. Please try again.';\n    }\n  }\n\n  /**\n   * REAL RSA encryption with recipient's public key\n   */\n  async _encryptWithPublicKey(data, publicKeyPem) {\n    console.log('RSA_ENCRYPT: Using REAL Web Crypto API RSA encryption');\n    \n    try {\n      // Convert PEM to ArrayBuffer\n      const publicKeyBuffer = this._pemToArrayBuffer(publicKeyPem);\n      \n      // Import the public key\n      const publicKey = await crypto.subtle.importKey(\n        'spki',\n        publicKeyBuffer,\n        {\n          name: 'RSA-OAEP',\n          hash: 'SHA-256'\n        },\n        false,\n        ['encrypt']\n      );\n      \n      // Encrypt the data\n      const dataBuffer = new TextEncoder().encode(data);\n      const encryptedBuffer = await crypto.subtle.encrypt(\n        {\n          name: 'RSA-OAEP'\n        },\n        publicKey,\n        dataBuffer\n      );\n      \n      // Convert to base64\n      const encryptedArray = new Uint8Array(encryptedBuffer);\n      const encrypted = btoa(String.fromCharCode(...encryptedArray));\n      \n      console.log('RSA_ENCRYPT: Successfully encrypted with recipient public key');\n      return encrypted;\n      \n    } catch (error) {\n      throw new Error(`RSA encryption failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * REAL RSA decryption with our private key\n   */\n  async _decryptWithPrivateKey(encryptedData, privateKeyPem) {\n    console.log('RSA_DECRYPT: Using REAL Web Crypto API RSA decryption');\n    \n    try {\n      // Convert PEM to ArrayBuffer\n      const privateKeyBuffer = this._pemToArrayBuffer(privateKeyPem);\n      \n      // Import the private key\n      const privateKey = await crypto.subtle.importKey(\n        'pkcs8',\n        privateKeyBuffer,\n        {\n          name: 'RSA-OAEP',\n          hash: 'SHA-256'\n        },\n        false,\n        ['decrypt']\n      );\n      \n      // Convert base64 to ArrayBuffer\n      const encryptedArray = new Uint8Array(\n        atob(encryptedData).split('').map(char => char.charCodeAt(0))\n      );\n      \n      // Decrypt the data\n      const decryptedBuffer = await crypto.subtle.decrypt(\n        {\n          name: 'RSA-OAEP'\n        },\n        privateKey,\n        encryptedArray\n      );\n      \n      // Convert back to string\n      const decrypted = new TextDecoder().decode(decryptedBuffer);\n      \n      console.log('RSA_DECRYPT: Successfully decrypted with our private key');\n      return decrypted;\n      \n    } catch (error) {\n      throw new Error(`RSA decryption failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Helper to convert PEM to ArrayBuffer\n   */\n  _pemToArrayBuffer(pem) {\n    const base64 = pem\n      .replace(/-----BEGIN [A-Z ]+-----/g, '')\n      .replace(/-----END [A-Z ]+-----/g, '')\n      .replace(/[\\r\\n\\s]/g, '');\n    \n    const binaryString = atob(base64);\n    const buffer = new ArrayBuffer(binaryString.length);\n    const view = new Uint8Array(buffer);\n    \n    for (let i = 0; i < binaryString.length; i++) {\n      view[i] = binaryString.charCodeAt(i);\n    }\n    \n    return buffer;\n  }\n\n  /**\n   * Sign data with RSA private key\n   */\n  async _signWithPrivateKey(data, privateKeyPem) {\n    return await CryptoService.signWithRSA(data, privateKeyPem);\n  }\n\n  /**\n   * Verify signature with RSA public key\n   */\n  async _verifyWithPublicKey(data, signature, publicKeyPem) {\n    return await CryptoService.verifyRSASignature(data, signature, publicKeyPem);\n  }\n}\n\n// Export singleton instance\nconst encryptionService = new EncryptionService();\nexport default encryptionService;"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1575, "column": 0}, "map": {"version":3,"sources":["file:///Users/aviasnani/Desktop/computer%20demo/cs-demo/repo/frontend/src/services/userPreferencesService.js"],"sourcesContent":["/**\n * UserPreferencesService - Manages user preferences for encryption and other settings\n * Handles storing/retrieving user preferences in localStorage with validation\n */\n\nclass UserPreferencesService {\n  constructor() {\n    this.storageKey = 'user_preferences';\n    this.defaultPreferences = {\n      encryption: {\n        clearKeysOnLogout: false, // Default to keeping keys for convenience\n        keyPersistenceAcrossSessions: true,\n        autoInitializeKeys: true\n      },\n      ui: {\n        showEncryptionIndicators: true,\n        showKeyInitializationProgress: true\n      }\n    };\n  }\n\n  /**\n   * Get all user preferences\n   * @returns {Object} User preferences object\n   */\n  getPreferences() {\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        // Merge with defaults to ensure all properties exist\n        return this._mergeWithDefaults(parsed);\n      }\n    } catch (error) {\n      console.error('Failed to load user preferences:', error);\n    }\n    \n    return { ...this.defaultPreferences };\n  }\n\n  /**\n   * Update user preferences\n   * @param {Object} preferences - Preferences to update\n   */\n  updatePreferences(preferences) {\n    try {\n      const current = this.getPreferences();\n      const updated = this._deepMerge(current, preferences);\n      localStorage.setItem(this.storageKey, JSON.stringify(updated));\n      return updated;\n    } catch (error) {\n      console.error('Failed to save user preferences:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get encryption-specific preferences\n   * @returns {Object} Encryption preferences\n   */\n  getEncryptionPreferences() {\n    return this.getPreferences().encryption;\n  }\n\n  /**\n   * Update encryption preferences\n   * @param {Object} encryptionPrefs - Encryption preferences to update\n   */\n  updateEncryptionPreferences(encryptionPrefs) {\n    return this.updatePreferences({ encryption: encryptionPrefs });\n  }\n\n  /**\n   * Check if keys should be cleared on logout\n   * @returns {boolean}\n   */\n  shouldClearKeysOnLogout() {\n    return this.getEncryptionPreferences().clearKeysOnLogout;\n  }\n\n  /**\n   * Check if keys should persist across sessions\n   * @returns {boolean}\n   */\n  shouldPersistKeysAcrossSessions() {\n    return this.getEncryptionPreferences().keyPersistenceAcrossSessions;\n  }\n\n  /**\n   * Check if keys should be auto-initialized\n   * @returns {boolean}\n   */\n  shouldAutoInitializeKeys() {\n    return this.getEncryptionPreferences().autoInitializeKeys;\n  }\n\n  /**\n   * Reset preferences to defaults\n   */\n  resetToDefaults() {\n    try {\n      localStorage.removeItem(this.storageKey);\n    } catch (error) {\n      console.error('Failed to reset preferences:', error);\n    }\n  }\n\n  /**\n   * Clear all preferences\n   */\n  clearPreferences() {\n    this.resetToDefaults();\n  }\n\n  /**\n   * Merge preferences with defaults to ensure all properties exist\n   * @private\n   */\n  _mergeWithDefaults(preferences) {\n    return this._deepMerge(this.defaultPreferences, preferences);\n  }\n\n  /**\n   * Deep merge two objects\n   * @private\n   */\n  _deepMerge(target, source) {\n    const result = { ...target };\n    \n    for (const key in source) {\n      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n        result[key] = this._deepMerge(target[key] || {}, source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    }\n    \n    return result;\n  }\n}\n\n// Export singleton instance\nconst userPreferencesService = new UserPreferencesService();\nexport default userPreferencesService;"],"names":[],"mappings":"AAAA;;;CAGC;;;AAED,MAAM;IACJ,aAAc;QACZ,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,kBAAkB,GAAG;YACxB,YAAY;gBACV,mBAAmB;gBACnB,8BAA8B;gBAC9B,oBAAoB;YACtB;YACA,IAAI;gBACF,0BAA0B;gBAC1B,+BAA+B;YACjC;QACF;IACF;IAEA;;;GAGC,GACD,iBAAiB;QACf,IAAI;YACF,MAAM,SAAS,aAAa,OAAO,CAAC,IAAI,CAAC,UAAU;YACnD,IAAI,QAAQ;gBACV,MAAM,SAAS,KAAK,KAAK,CAAC;gBAC1B,qDAAqD;gBACrD,OAAO,IAAI,CAAC,kBAAkB,CAAC;YACjC;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,oCAAoC;QACpD;QAEA,OAAO;YAAE,GAAG,IAAI,CAAC,kBAAkB;QAAC;IACtC;IAEA;;;GAGC,GACD,kBAAkB,WAAW,EAAE;QAC7B,IAAI;YACF,MAAM,UAAU,IAAI,CAAC,cAAc;YACnC,MAAM,UAAU,IAAI,CAAC,UAAU,CAAC,SAAS;YACzC,aAAa,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,SAAS,CAAC;YACrD,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,oCAAoC;YAClD,MAAM;QACR;IACF;IAEA;;;GAGC,GACD,2BAA2B;QACzB,OAAO,IAAI,CAAC,cAAc,GAAG,UAAU;IACzC;IAEA;;;GAGC,GACD,4BAA4B,eAAe,EAAE;QAC3C,OAAO,IAAI,CAAC,iBAAiB,CAAC;YAAE,YAAY;QAAgB;IAC9D;IAEA;;;GAGC,GACD,0BAA0B;QACxB,OAAO,IAAI,CAAC,wBAAwB,GAAG,iBAAiB;IAC1D;IAEA;;;GAGC,GACD,kCAAkC;QAChC,OAAO,IAAI,CAAC,wBAAwB,GAAG,4BAA4B;IACrE;IAEA;;;GAGC,GACD,2BAA2B;QACzB,OAAO,IAAI,CAAC,wBAAwB,GAAG,kBAAkB;IAC3D;IAEA;;GAEC,GACD,kBAAkB;QAChB,IAAI;YACF,aAAa,UAAU,CAAC,IAAI,CAAC,UAAU;QACzC,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;QAChD;IACF;IAEA;;GAEC,GACD,mBAAmB;QACjB,IAAI,CAAC,eAAe;IACtB;IAEA;;;GAGC,GACD,mBAAmB,WAAW,EAAE;QAC9B,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE;IAClD;IAEA;;;GAGC,GACD,WAAW,MAAM,EAAE,MAAM,EAAE;QACzB,MAAM,SAAS;YAAE,GAAG,MAAM;QAAC;QAE3B,IAAK,MAAM,OAAO,OAAQ;YACxB,IAAI,MAAM,CAAC,IAAI,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,YAAY,CAAC,MAAM,OAAO,CAAC,MAAM,CAAC,IAAI,GAAG;gBACjF,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,GAAG,MAAM,CAAC,IAAI;YAC9D,OAAO;gBACL,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;YAC3B;QACF;QAEA,OAAO;IACT;AACF;AAEA,4BAA4B;AAC5B,MAAM,yBAAyB,IAAI;uCACpB","debugId":null}},
    {"offset": {"line": 1709, "column": 0}, "map": {"version":3,"sources":["file:///Users/aviasnani/Desktop/computer%20demo/cs-demo/repo/frontend/src/context/AuthContext.js"],"sourcesContent":["'use client'\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport encryptionService from '../services/encryptionService';\nimport userPreferencesService from '../services/userPreferencesService';\n\nconst AuthContext = createContext({});\n\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [currentUser, setCurrentUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [keyInitialization, setKeyInitialization] = useState({\n    isInitializing: false,\n    progress: 0,\n    status: null,\n    error: null\n  });\n\n  useEffect(() => {\n    // Check if user is already authenticated\n    checkAuthStatus();\n  }, []);\n\n  const checkAuthStatus = async () => {\n    try {\n      const backendUrl = process.env.NEXT_PUBLIC_WEBSOCKET_URL || 'http://localhost:5000';\n      const response = await fetch(`${backendUrl}/api/auth/me`, {\n        method: 'GET',\n        credentials: 'include',\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        if (data.status === 'success') {\n          // Create user object compatible with the app\n          const user = {\n             uid: data.data.id.toString(),\n              email: data.data.email,\n              displayName: data.data.display_name,\n              username: data.data.username,\n              githubUsername: data.data.github_username,  \n              photoURL: data.data.profile_picture,\n              accessToken: 'local-auth-token'\n          };\n          setCurrentUser(user);\n          setError(null);\n          \n          // Initialize encryption keys for existing session\n          await initializeEncryptionKeys(user);\n        } else {\n          setCurrentUser(null);\n        }\n      } else {\n        setCurrentUser(null);\n      }\n    } catch (err) {\n      console.error('Auth check error:', err);\n      setCurrentUser(null);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const initializeEncryptionKeys = async (user) => {\n    try {\n      setKeyInitialization({\n        isInitializing: true,\n        progress: 0,\n        status: 'Initializing encryption keys...',\n        error: null\n      });\n\n      // Progress: Starting key initialization\n      setKeyInitialization(prev => ({\n        ...prev,\n        progress: 20,\n        status: 'Checking existing keys...'\n      }));\n\n      // Initialize encryption service with user credentials\n      const success = await encryptionService.initialize(user.uid, user.accessToken);\n      \n      if (success) {\n        setKeyInitialization(prev => ({\n          ...prev,\n          progress: 100,\n          status: 'Encryption keys ready',\n          isInitializing: false\n        }));\n        \n        // Clear status after a short delay\n        setTimeout(() => {\n          setKeyInitialization({\n            isInitializing: false,\n            progress: 0,\n            status: null,\n            error: null\n          });\n        }, 2000);\n      } else {\n        throw new Error('Failed to initialize encryption keys');\n      }\n    } catch (error) {\n      console.error('Key initialization error:', error);\n      setKeyInitialization({\n        isInitializing: false,\n        progress: 0,\n        status: null,\n        error: error.message || 'Failed to initialize encryption keys'\n      });\n    }\n  };\n\n  const logout = async (options = {}) => {\n    try {\n      setLoading(true);\n      \n      // Check user preferences for key cleanup\n      const shouldClearKeys = options.clearKeys !== undefined \n        ? options.clearKeys \n        : userPreferencesService.shouldClearKeysOnLogout();\n      \n      // Clear encryption keys based on user preference\n      if (currentUser && shouldClearKeys) {\n        await encryptionService.clearKeys();\n        console.log('Encryption keys cleared on logout');\n      } else if (currentUser) {\n        console.log('Encryption keys preserved on logout (user preference)');\n      }\n      \n      // Clear backend session\n      const backendUrl = process.env.NEXT_PUBLIC_WEBSOCKET_URL || 'http://localhost:5000';\n      await fetch(`${backendUrl}/api/auth/logout`, {\n        method: 'POST',\n        credentials: 'include',\n      });\n      \n      setCurrentUser(null);\n      setError(null);\n      setKeyInitialization({\n        isInitializing: false,\n        progress: 0,\n        status: null,\n        error: null\n      });\n    } catch (err) {\n      console.error('Logout error:', err);\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const clearError = () => {\n    setError(null);\n  };\n\n  const refreshUser = async () => {\n    setLoading(true);\n    await checkAuthStatus();\n  };\n\n  const login = async (user) => {\n    setCurrentUser(user);\n    setError(null);\n    \n    // Initialize encryption keys after successful login\n    await initializeEncryptionKeys(user);\n  };\n\n  const updateUserPreferences = (preferences) => {\n    return userPreferencesService.updatePreferences(preferences);\n  };\n\n  const getUserPreferences = () => {\n    return userPreferencesService.getPreferences();\n  };\n\n  const clearKeysManually = async () => {\n    if (currentUser) {\n      await encryptionService.clearKeys();\n      console.log('Encryption keys manually cleared');\n    }\n  };\n\n  const value = {\n    currentUser,\n    login,\n    logout,\n    loading,\n    error,\n    clearError,\n    refreshUser,\n    keyInitialization,\n    updateUserPreferences,\n    getUserPreferences,\n    clearKeysManually\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1922, "column": 0}, "map": {"version":3,"sources":["file:///Users/aviasnani/Desktop/computer%20demo/cs-demo/repo/frontend/src/components/ErrorBoundary.js"],"sourcesContent":["\"use client\"\nimport React from 'react';\nimport { AlertTriangle, RefreshCw, Home } from 'lucide-react';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n\n    // Log error to console in development\n    if (process.env.NODE_ENV === 'development') {\n      console.error('Error caught by boundary:', error, errorInfo);\n    }\n\n    // In production, you would send this to an error reporting service\n    // Example: Sentry, LogRocket, etc.\n    if (process.env.NODE_ENV === 'production') {\n      // logErrorToService(error, errorInfo);\n    }\n  }\n\n  handleReload = () => {\n    window.location.reload();\n  };\n\n  handleGoHome = () => {\n    window.location.href = '/';\n  };\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"min-h-screen flex items-center justify-center bg-gray-50 px-4\">\n          <div className=\"max-w-md w-full text-center\">\n            <div className=\"bg-white rounded-lg shadow-lg p-8\">\n              <div className=\"w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <AlertTriangle className=\"w-8 h-8 text-red-600\" />\n              </div>\n              \n              <h1 className=\"text-xl font-semibold text-gray-900 mb-2\">\n                Something went wrong\n              </h1>\n              \n              <p className=\"text-gray-600 mb-6\">\n                We&apos;re sorry, but something unexpected happened. Please try refreshing the page or go back to the home page.\n              </p>\n\n              {process.env.NODE_ENV === 'development' && this.state.error && (\n                <div className=\"bg-red-50 border border-red-200 rounded-md p-4 mb-6 text-left\">\n                  <h3 className=\"text-sm font-medium text-red-800 mb-2\">Error Details:</h3>\n                  <pre className=\"text-xs text-red-700 overflow-auto max-h-32\">\n                    {this.state.error.toString()}\n                    {this.state.errorInfo.componentStack}\n                  </pre>\n                </div>\n              )}\n\n              <div className=\"flex flex-col sm:flex-row gap-3\">\n                <button\n                  onClick={this.handleReload}\n                  className=\"flex-1 flex items-center justify-center px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors\"\n                >\n                  <RefreshCw className=\"w-4 h-4 mr-2\" />\n                  Refresh Page\n                </button>\n                \n                <button\n                  onClick={this.handleGoHome}\n                  className=\"flex-1 flex items-center justify-center px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 transition-colors\"\n                >\n                  <Home className=\"w-4 h-4 mr-2\" />\n                  Go Home\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;"],"names":[],"mappings":";;;AAqBQ;;AApBR;AACA;AAAA;AAAA;AAFA;;;;AAIA,MAAM,sBAAsB,6JAAA,CAAA,UAAK,CAAC,SAAS;IACzC,YAAY,KAAK,CAAE;QACjB,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG;YAAE,UAAU;YAAO,OAAO;YAAM,WAAW;QAAK;IAC/D;IAEA,OAAO,yBAAyB,KAAK,EAAE;QACrC,OAAO;YAAE,UAAU;QAAK;IAC1B;IAEA,kBAAkB,KAAK,EAAE,SAAS,EAAE;QAClC,IAAI,CAAC,QAAQ,CAAC;YACZ,OAAO;YACP,WAAW;QACb;QAEA,sCAAsC;QACtC,wCAA4C;YAC1C,QAAQ,KAAK,CAAC,6BAA6B,OAAO;QACpD;QAEA,mEAAmE;QACnE,mCAAmC;QACnC,IAAI,oDAAyB,cAAc;QACzC,uCAAuC;QACzC;IACF;IAEA,eAAe;QACb,OAAO,QAAQ,CAAC,MAAM;IACxB,EAAE;IAEF,eAAe;QACb,OAAO,QAAQ,CAAC,IAAI,GAAG;IACzB,EAAE;IAEF,SAAS;QACP,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;YACvB,qBACE,6LAAC;gBAAI,WAAU;0BACb,cAAA,6LAAC;oBAAI,WAAU;8BACb,cAAA,6LAAC;wBAAI,WAAU;;0CACb,6LAAC;gCAAI,WAAU;0CACb,cAAA,6LAAC,2NAAA,CAAA,gBAAa;oCAAC,WAAU;;;;;;;;;;;0CAG3B,6LAAC;gCAAG,WAAU;0CAA2C;;;;;;0CAIzD,6LAAC;gCAAE,WAAU;0CAAqB;;;;;;4BAIjC,oDAAyB,iBAAiB,IAAI,CAAC,KAAK,CAAC,KAAK,kBACzD,6LAAC;gCAAI,WAAU;;kDACb,6LAAC;wCAAG,WAAU;kDAAwC;;;;;;kDACtD,6LAAC;wCAAI,WAAU;;4CACZ,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ;4CACzB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,cAAc;;;;;;;;;;;;;0CAK1C,6LAAC;gCAAI,WAAU;;kDACb,6LAAC;wCACC,SAAS,IAAI,CAAC,YAAY;wCAC1B,WAAU;;0DAEV,6LAAC,mNAAA,CAAA,YAAS;gDAAC,WAAU;;;;;;4CAAiB;;;;;;;kDAIxC,6LAAC;wCACC,SAAS,IAAI,CAAC,YAAY;wCAC1B,WAAU;;0DAEV,6LAAC,sMAAA,CAAA,OAAI;gDAAC,WAAU;;;;;;4CAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAQ/C;QAEA,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ;IAC5B;AACF;uCAEe","debugId":null}}]
}